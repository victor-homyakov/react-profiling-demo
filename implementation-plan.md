# Пошаговый план создания демо-приложения (React 19)

План разбит на фазы. Каждый шаг можно выполнять последовательно; зависимости между фазами указаны.

---

## Фаза 0: Подготовка проекта

### Шаг 0.1 — Инициализация Vite + React

- Создать проект: `npm create vite@latest . -- --template react-ts`.
- Убедиться, что используется **React 19** (`react` и `react-dom` ^19) и TypeScript.
- Установить зависимости, проверить `npm run dev` и `npm run build`.

### Шаг 0.2 — Роутинг и базовая структура

- Установить React Router (например, `react-router-dom` ^7).
- Создать структуру папок:
    - `src/pages/` — страницы-разделы;
    - `src/components/` — переиспользуемые компоненты;
    - `src/demos/` — компоненты демо по темам (или группировать по страницам);
    - `src/hooks/` — кастомные хуки (useWhyDidYouUpdate и др.).
- Настроить роуты: главная (навигация) + маршруты для каждого блока плана.

### Шаг 0.3 — Режимы сборки (development / production / profiling)

- В `vite.config.*`: задать `define` или использование `import.meta.env.MODE`.
- Добавить npm-скрипты:
    - `dev` — development (уже есть);
    - `build` — production;
    - `build:profiling` — сборка с profiling-версией React (например, через `NODE_OPTIONS` или env `GENERATE_SOURCEMAP`, и подмена react-dom на profiling; см. документацию React).
- Добавить в проект алиас или условный импорт для `react-dom/profiling` и `scheduler/tracing` (если нужны для profiling-билда).
- В README описать, как запускать в трёх режимах и чем они отличаются.

### Шаг 0.4 — Strict Mode и переключатель

- Обернуть приложение в `<StrictMode>` в `main.tsx` (или в корневом layout).
- Добавить возможность **отключать** Strict Mode для демо (через переключатель на странице и последующий ререндер).
- На главной или в футере вывести текущий режим (dev/prod/profiling) и состояние Strict Mode — для наглядности на докладе.

---

## Фаза 1: Оболочка приложения и навигация

### Шаг 1.1 — Layout и навигация по разделам

- Создать общий layout: шапка, сайдбар или табы с разделами, область контента.
- Разделы (страницы) по плану:
    1. **Сборки и окружение** — описание режимов, переключатель Strict Mode.
    2. **React DevTools** — причины рендера, мемоизация, нестабильные пропсы.
    3. **React Profiler** — лёгкий/тяжёлый рендер, Self-profiling.
    4. **DevTools Performance** — тяжёлый сценарий, Strict Mode.
    5. **useTransition** — фильтр с/без transition, медленный vs частые рендеры, UI starvation.
    6. **INP и мемоизация** — GC/Layout, useMemo-кейсы, WDYR, useWhyDidYouUpdate, частые/долгие ререндеры.
    7. **Память и утечки** — queryObjects, Performance monitor, Detached, useMemo не утечка, Allocations, три снапшота.
- Для каждого раздела создать страницу-заглушку с заголовком и кратким текстом «что здесь демонстрировать».

### Шаг 1.2 — Единый стиль и подсказки

- Добавить минимальные стили (CSS-модули или один глобальный файл), чтобы разделы были читаемы.
- Где нужно — блоки «Подсказка для докладчика» с текстом вроде: «Открой React Profiler → Record → нажми кнопку».

---

## Фаза 2: React DevTools (раздел 2 требований)

### Шаг 2.1 — Демо «Причины рендера и мемоизация»

- Создать страницу/подраздел с родительским компонентом, который часто обновляет state (например, счётчик или таймер).
- Добавить несколько дочерних компонентов:
    - без `memo` — ререндерятся при каждом обновлении родителя;
    - с `React.memo` и стабильными пропсами — не ререндерятся.
- Показать в UI счётчики рендеров (useRef + увеличение в рендере), чтобы было видно разницу даже без DevTools.
- В подсказке указать: «В React DevTools включи «Highlight updates» и посмотри причины рендера».

### Шаг 2.2 — Демо «Нестабильные vs стабильные пропсы»

- Два варианта одного и того же списка/карточек:
    - **Плохие пропсы:** передавать в каждый элемент `onClick={() => {...}}`, `style={{ margin: 5 }}`, `data={[...]}` без useCallback/useMemo — мемоизация «не срабатывает».
    - **Хорошие пропсы:** те же данные и колбэки, но обёрнутые в useCallback/useMemo с правильными зависимостями — ререндеров меньше.
- Счётчики рендеров на дочерних компонентах (с memo) для наглядности.
- Подсказка: «Подключи WDYR и сравни консоль в двух режимах».

---

## Фаза 3: React Profiler и DevTools Performance (разделы 3-4)

### Шаг 3.1 — Лёгкий и тяжёлый рендер

- На странице «React Profiler» две кнопки/вкладки: «Лёгкий рендер» и «Тяжёлый рендер».
- **Лёгкий:** простой компонент, обновляющий небольшой список по клику.
- **Тяжёлый:** при обновлении выполнять искусственную задержку (например, цикл или тяжёлое вычисление в рендере/useMemo), чтобы в React Profiler было видно длинный commit.
- Подсказка: «Включи запись в React Profiler, нажми кнопку, посмотри флеймграф».

### Шаг 3.2 — Скрипт сборки с profiling и инструкция

- Доработать `build:profiling` так, чтобы при сборке подставлялась profiling-версия react-dom (по документации React).
- В README добавить раздел: «Как собрать и открыть приложение в режиме profiling для записи React Profiler в продакшен-подобном окружении».

### Шаг 3.3 — Self-profiling API

- Изучить API (например, `react-dom` profiling или экспериментальные хуки), добавить кнопку «Записать профиль» или «Старт записи» / «Стоп и скачать».
- По остановке — экспорт профиля (если API даёт объект) в JSON и скачивание файла или вывод сводки в консоль.
- Кратко описать в подсказке на странице и в README.

### Шаг 3.4 — Связка с DevTools Performance и Strict Mode

- Использовать тот же «тяжёлый» сценарий на странице «DevTools Performance».
- Добавить подсказку: записать Performance при клике, обратить внимание на Scripting и на двойной вызов при Strict Mode.
- Переключатель Strict Mode (из шага 0.4) использовать для сравнения одной и той же операции с/без Strict Mode.

---

## Фаза 4: useTransition и конкурентный рендеринг (раздел 5)

### Шаг 4.1 — Фильтр списка с useTransition и без

- Одна страница или два блока: поле ввода + список из большого количества элементов (например, 10k строк), фильтрация по вводу.
- **Вариант A:** обновление state при каждом `onChange` без `startTransition` — блокирующий ввод.
- **Вариант B:** обновление фильтра через `startTransition` — отзывчивый ввод.
- Подсказка: «В React Profiler посмотри прерванные рендеры и приоритеты при быстром вводе в варианте B».

### Шаг 4.2 — Медленный рендер vs частые попытки

- **Медленный рендер:** один большой список, который рендерится за один commit (много элементов или тяжёлый рендер каждого) — в профиле один длинный бар.
- **Частые попытки:** тот же список или форма, но state обновляется очень часто (например, при каждом нажатии клавиши без transition), в конкурентном режиме — много коротких/прерванных работ в профиле.
- Два отдельных демо-блока или вкладки с подсказками, что смотреть в Profiler.

### Шаг 4.3 — UI starvation: три примера

- **Вкладка 1 — useLayoutEffect + getBoundingClientRect:** компонент, в useLayoutEffect читающий getBoundingClientRect у многих элементов или в цикле, и обновляющий state — показать блокировку paint.
- **Вкладка 2 — Тяжёлый onInput без useTransition:** поле ввода, при каждом onInput выполняющее тяжёлое обновление (большой ререндер или вычисление) — субъективно «лаг» при вводе.
- **Вкладка 3 — Медленный layout:** сетка из очень большого числа элементов с тяжёлым CSS (например, много flex/grid), при обновлении которых в Performance виден долгий Layout.
- Для каждого — короткая подсказка в UI и в README.

---

## Фаза 5: INP и диагностика мемоизации (раздел 6)

### Шаг 5.1 — INP: задержка из-за GC или Layout

- **GC:** кнопка или поле ввода, при действии которого создаётся много временных объектов (например, массив из тысяч элементов без мемоизации), чтобы в Performance было видно всплеск GC после Scripting.
- **Layout:** кнопка, которая триггерит обновление DOM, вызывающее большой reflow (например, изменение размеров/позиций многих элементов) — в Performance долгий Layout.
- Подсказка: «React может отрендериться быстро; смотри, что INP/задержка уходит в GC или Layout».

### Шаг 5.2 — useMemo/useCallback и INP: три варианта

- Один и тот же компонент (список с фильтром) в трёх вариантах:
    - **Правильная мемоизация:** только тяжёлые вычисления и колбэки, передаваемые в memo-компоненты, стабилизированы.
    - **Излишняя мемоизация:** много useMemo/useCallback с большими массивами зависимостей и лёгкими вычислениями — лишняя работа на сравнении.
    - **Неправильная мемоизация:** нестабильные зависимости или мемоизация не того — ререндеры не уменьшаются, плюс накладные расходы.
- Добавить замер длительности рендера (performance.now до/после рендера через useEffect или ref) и выводить на экран/в консоль; при возможности — замер INP (например, через PerformanceObserver или reportWebVitals).

### Шаг 5.3 — Подключение WDYR

- Установить и настроить `@welldone-software/why-did-you-render` (или аналог) для dev-сборки.
- На странице с нестабильными пропсами (из шага 2.2) обернуть компоненты в `whyDidYouRender`; в консоли должны появляться сообщения о ререндерах из-за новых ссылок.
- В README указать, как включить WDYR и что смотреть.

### Шаг 5.4 — Хук useWhyDidYouUpdate

- Реализовать хук `useWhyDidYouUpdate(name, props)`: в useEffect (или при каждом рендере через ref) сравнивать текущие props с предыдущими и выводить в консоль, какие ключи изменились и старые/новые значения.
- Использовать на 1-2 компонентах на странице «Кандидаты на мемоизацию» с разными пропсами (объект, функция, примитив).
- Подсказка: «Смотри консоль при действиях — какие пропсы меняются».

### Шаг 5.5 — Частые и длительные ререндеры

- Два демо:
    - **Частые:** компонент, который обновляется по таймеру или по быстрым событиям много раз подряд — в Profiler много коротких коммитов.
    - **Длинные:** один тяжёлый рендер (как в шаге 3.1) — один долгий коммит.
- Опционально: простой логгер времени рендера и «причины» (например, какой state изменился) через ref + useEffect; упомянуть в подсказке про pnpm-патч React при необходимости.

---

## Фаза 6: Память и утечки (раздел 7)

### Шаг 6.1 — queryObjects

- Создать класс или «тип» компонента (например, функциональный компонент, обёрнутый так, чтобы при необходимости можно было опознать экземпляры), либо использовать классовый компонент для наглядности.
- Экспортировать компонент в window для удобного вызова queryObjects.
- Демо: модалка (или страница), при открытии которой монтируется компонент, при закрытии — размонтируется, но накапливает ссылки на свой DOM-элемент в глобальной переменной (window) или в переменной модуля.
- При открытии создаётся N подписок (например, таймеры или event listeners), при размонтировании подписки **не** отписываются.
- Краткая инструкция на странице: «В консоли выполни `queryObjects(Object)`, `queryObjects(HTMLElement)`, `queryObjects(ComponentName)` до открытия, открой, закрой, выполни снова — сравни количество».

### Шаг 6.2 — Утечка подписок (Performance monitor)

- Модалка из шага 6.1.
- Демо: открыть Performance monitor (Chrome); открыть/закрыть модалку; в Performance monitor наблюдать рост heap.
- Подсказка в UI с шагами.

### Шаг 6.3 — Detached DOM

- Модалка из шага 6.1.
- Демо: открыть/закрыть модалку; в Chrome Memory поискать Detached HTMLDivElement (или соответствующий тег) и показать цепочку удержания.
- Краткая инструкция на странице.

### Шаг 6.4 — useMemo и кэш — не утечка

- Компонент с useMemo (и опционально простой селектор с кэшем в духе reselect); при размонтировании кэш не должен удерживаться.
- Демо: смонтировать, снять snapshot — показать кэш, размонтировать, снять snapshot — показать, что кэш не накапливается при повторных монтированиях, или что объём не растёт бесконечно (если кэш с лимитом).
- Короткий текст в UI: «Кэш привязан к компоненту / ограничен — это не утечка».

### Шаг 6.5 — Allocations on timeline

- Использовать сценарий с утечкой подписок (шаг 6.2): повторяемое действие, после которого в heap остаются объекты.
- Инструкция: включить Memory → Allocations on timeline, выполнить действие многократно, показать остающиеся аллоцированными объекты на таймлайне.

### Шаг 6.6 — Метод трёх снапшотов

- Текстовая инструкция на странице (или в README): Snapshot 1 — начальное состояние; Snapshot 2 — открыть/закрыть модалку с утечкой N раз; Snapshot 3 — повторить ещё N раз. Сравнить 2 и 3, найти объекты, которые растут — кандидаты на утечку.
- Использовать ту же утечку (подписки или detached DOM), чтобы можно было пройти шаги за один доклад.

---

## Фаза 7: Документация и финализация

### Шаг 7.1 — README

- Описание проекта и цели (демо для Podlodka React Crew).
- Как запустить: `npm run dev`, `npm run build` + preview, `npm run build:profiling` + как открыть.
- Разделы по каждому демо: что показывать, какие инструменты открыть, что смотреть (React DevTools, Profiler, Performance, Memory, WDYR).
- Ссылки: React DevTools, WDYR, Self-profiling API (если есть официальная дока), Chrome DevTools Memory/Performance.

### Шаг 7.2 — Проверка по чек-листу

- Пройти таблицу из раздела 9 требований: для каждой строки убедиться, что в приложении есть соответствующий сценарий и при необходимости подсказка.
- Добавить на главную страницу или в навигацию короткий список разделов с номерами пунктов плана (для удобства на докладе).

### Шаг 7.3 — Небольшая полировка

- Убедиться, что переключение между разделами без ошибок, что все демо работают в dev и по возможности в production/profiling.
- При необходимости вынести общие компоненты (кнопки, карточки, счётчики рендеров) в `src/components/` для единообразия.

---

## Порядок выполнения (кратко)

1. **Фаза 0** — проект, роутинг, режимы сборки, Strict Mode.
2. **Фаза 1** — layout, навигация, заглушки страниц.
3. **Фаза 2** — React DevTools (мемоизация, нестабильные пропсы).
4. **Фаза 3** — React Profiler (лёгкий/тяжёлый, profiling-билд, Self-profiling), DevTools Performance.
5. **Фаза 4** — useTransition, медленный vs частые рендеры, UI starvation.
6. **Фаза 5** — INP (GC/Layout), useMemo-кейсы, WDYR, useWhyDidYouUpdate, частые/долгие ререндеры.
7. **Фаза 6** — все демо памяти (queryObjects, подписки, detached, useMemo, allocations, три снапшота).
8. **Фаза 7** — README, чек-лист, полировка.

Зависимости: фазы 2-6 можно частично распараллеливать после фазы 1; фаза 7 — в конце.
