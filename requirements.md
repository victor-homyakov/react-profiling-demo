# Требования к демо-приложению React 19

Демо-приложение должно позволять продемонстрировать все пункты плана выступления по профилированию и памяти в React.

---

## 1. Сборка и окружение

### 1.1 Три типа сборок react-dom

- **Требование:** Возможность запускать приложение в трёх режимах:
    - **development** — dev-сборка react-dom (по умолчанию в `npm run dev`)
    - **production** — production-сборка (например, `npm run build` + превью)
    - **profiling** — profiling-сборка react-dom (через переменные окружения / конфиг Vite/Webpack)
- **Демо:** Переключение между режимами и краткая подсказка, чем они отличаются (в UI или в README).

### 1.2 Strict Mode

- **Требование:** Включённый React Strict Mode в dev, чтобы можно было показать двойной рендер и его влияние на профиль/DevTools Performance.

---

## 2. React DevTools

### 2.1 Причины рендера и мемоизация

- **Требование:** Набор компонентов, где:
    - одни ререндерятся по пропсам/контексту/стейту;
    - другие обёрнуты в `React.memo` и не ререндерятся при неизменных пропсах;
    - в DevTools видно «почему компонент отрендерился» и «какие не ререндерились».
- **Демо:** Родитель с частыми обновлениями, дочерние компоненты — часть с memo, часть без; список/таблица или дерево компонентов для наглядности.

### 2.2 Нестабильные пропсы (для WDYR / useWhyDidYouUpdate)

- **Требование:** Компоненты, которые получают:
    - нестабильные пропсы (новые объекты/массивы/функции каждый рендер) — мемоизация «не работает»;
    - стабильные пропсы (useMemo/useCallback) — мемоизация «работает».
- **Демо:** Переключатель или два сценария: «плохие пропсы» vs «хорошие пропсы», чтобы показать разницу в ререндерах и в INP (если применимо).

---

## 3. React Profiler

### 3.1 Локальное использование

- **Требование:** Сценарии с разной «тяжестью» рендера:
    - лёгкие компоненты;
    - компоненты с искусственной задержкой (например, цикл/тяжёлые вычисления) для наглядного времени рендера в Profiler.
- **Демо:** Кнопки/вкладки, переключающие «лёгкий» и «тяжёлый» режим; запись в React Profiler и разбор флеймграфа.

### 3.2 Использование в продакшене

- **Требование:** Инструкция/скрипт для сборки с profiling-режимом и развёртывания (или локального превью), чтобы включить React Profiler на «продакшен-подобном» билде.

### 3.3 Self-profiling API

- **Требование:** Пример использования Self-profiling API (например, `reportWebVitals` или кастомная отправка метрик рендера) в контексте «профилирование в продакшене».
- **Демо:** Кнопка «записать профиль» или автоматическая запись при определённом действии, с возможностью скачать/отправить профиль (или вывести сводку в консоль).

---

## 4. DevTools Performance (Chrome)

### 4.1 Локальный сценарий

- **Требование:** Действия, которые создают заметную нагрузку (частые ререндеры, тяжёлые вычисления), чтобы на записи Performance было видно:
    - время скриптинга;
    - влияние Strict Mode (двойной рендер в dev).
- **Демо:** Тот же «тяжёлый» сценарий, что и для React Profiler; запись в Performance до/после оптимизации.

### 4.2 Strict Mode и dev-сборка

- **Требование:** Возможность включить/выключить Strict Mode и сравнить одну и ту же операцию в Performance (например, один и тот же клик или ввод).

---

## 5. useTransition и конкурентный рендеринг

### 5.1 Профиль с useTransition

- **Требование:** Компонент с `useTransition`: обновление списка/фильтра/поиска с `startTransition`, чтобы в профиле было видно:
    - прерванные рендеры;
    - приоритеты (transition vs срочные обновления).
- **Демо:** Поле ввода + фильтрация большого списка: один вариант без transition, другой с transition; сравнение в React Profiler.

### 5.2 Медленный рендер vs частые попытки рендера

- **Требование:** Два типа сценариев:
    - **медленный рендер:** один долгий commit (например, тяжёлый список за один раз);
    - **частые попытки:** быстрые, но многократные обновления (например, ввод без debounce/transition), много прерываний в конкурентном режиме.
- **Демо:** Два режима/страницы, чтобы в профиле было наглядно видно разницу.

### 5.3 UI starvation

- **Требование:** Примеры причин «голодания» UI:
    - **useLayoutEffect + getBoundingClientRect** — синхронная работа в layout, блокирующая отрисовку;
    - **тяжёлое обновление на onInput без useTransition** — частые синхронные ререндеры при вводе;
    - **медленный layout** — сложная разметка (много элементов, сложный CSS), чтобы на Performance было видно долгий Layout.
- **Демо:** Три мини-примера или три вкладки: LayoutEffect+getBoundingClientRect, input без transition, «сложная разметка» (например, большой grid/flex с измерением).

---

## 6. Диагностика проблем (INP, мемоизация)

### 6.1 INP: «React рендерит быстро, INP 500 ms»

- **Требование:** Сценарий, где задержка ощущается пользователем, но основное время уходит не на React, а на:
    - **GC** — например, создание множества объектов при вводе (без мемоизации);
    - **Layout** — сложный reflow при обновлении DOM.
- **Демо:** Кнопка/поле, по которой видно в Performance, что основное время — в Layout или GC, а не в Scripting; при необходимости — подсказка в UI.

### 6.2 useMemo/useCallback и INP

- **Требование:** Два кейса:
    - **мемоизация работает, но замедляет INP:** большое количество мемоизированных лёгких вычислений, в каждом из них большой массив зависимостей;
    - **мемоизация не работает и замедляет INP:** лишние useMemo/useCallback создают доп. работу (сравнение зависимостей, замыкания) и могут ухудшить INP при частых обновлениях.
- **Демо:** Три варианта одного и того же компонента (с «правильной», «излишней» и «неправильной» мемоизацией), замер длительности ререндеров с выводом на экран и в консоль, замер INP или хотя бы субъективная отзывчивость.

### 6.3 Плохая мемоизация и нестабильные пропсы — WDYR

- **Требование:** Компоненты, на которых удобно включить **Why Did You Render (WDYR)** и увидеть:
    - ререндеры из-за новых ссылок на объекты/функции/массивы;
    - предупреждения о нестабильных пропсах.
- **Демо:** Один и тот же список/форма с намеренно нестабильными пропсами; после включения WDYR в консоли — понятные сообщения.

### 6.4 Кандидаты на мемоизацию — useWhyDidYouUpdate

- **Требование:** Хук или небольшой HOC по типу useWhyDidYouUpdate: логирование, какие пропсы изменились между рендерами.
- **Демо:** Использование на 1-2 компонентах с разными пропсами; в консоли видно «prevProps vs nextProps» и какие ключи изменились.

### 6.5 Частые и длительные ререндеры

- **Требование:** Сценарии для поиска:
    - **частых** ререндеров (много коротких коммитов);
    - **длинных** ререндеров (один тяжёлый коммит).
- **Демо:** Можно использовать идеи WDYR или «производную» (логирование времени рендера + причина); при желании — упоминание pnpm-патча React для детального логирования.

---

## 7. Память и утечки

### 7.1 Диагностика факта утечки

#### 7.1.1 queryObjects

- **Требование:** Глобальная ссылка на какой-то класс/тип компонентов или объектов приложения, чтобы в консоли можно было вызвать `queryObjects(MyComponent)` (или аналог) и показать «висящие» экземпляры после размонтирования.
- **Демо:** Модалка, которая монтируется и размонтируется; вызов queryObjects до и после — разница в количестве объектов.

#### 7.1.2 Performance monitor

- **Требование:** Сценарий, при котором растёт использование памяти (например, многократное создание подписок/замыканий без очистки), чтобы в Performance monitor (Chrome) был виден рост heap.
- **Демо:** Кнопка «создать N подписок» без отписки при размонтировании; повторное открытие/закрытие; наблюдение за памятью.

#### 7.1.3 Memory — Detached elements

- **Требование:** Классическая утечка через detached DOM: ссылка на DOM-элемент в замыкании или в глобальной переменной после удаления из документа.
- **Демо:** Компонент, который при размонтировании оставляет ссылку на свой DOM-элемент (например, в window или в модульной переменной); в Memory — поиск Detached HTMLDivElement (или аналог).

#### 7.1.4 Память в useMemo и reselect — не утечки

- **Требование:** Примеры кэширования в памяти, которые не являются утечками:
    - `useMemo` с зависимостями — кэш привязан к жизненному циклу компонента;
    - библиотека в духе reselect (или простой селектор с кэшем) — кэш ограничен по размеру или по подписке.
- **Демо:** Компонент с useMemo и (опционально) с селектором; показать, что после размонтирования кэш больше не удерживается (или что кэш ограничен).

### 7.2 Поиск утечки

#### 7.2.1 Memory — Allocations on timeline

- **Требование:** Действие, которое при повторении оставляет всё больше объектов в heap (например, подписка без отписки, накопление в массиве).
- **Демо:** Запись Allocation timeline при многократном выполнении действия; показать рост определённого типа объектов.

#### 7.2.2 Метод трёх снапшотов

- **Требование:** Сценарий, подходящий для метода трёх снапшотов:
    - Snapshot 1: начальное состояние;
    - Snapshot 2: выполнили действие (например, открыли и закрыли модалку 10 раз);
    - Snapshot 3: повторили то же действие ещё N раз.
    - Сравнение 2 и 3: объекты, которые «остались» между 2 и 3 — кандидаты на утечку.
- **Демо:** Одна и та же утечка (например, из п. 7.1.3 или 7.1.2), снятие трёх снапшотов и краткая инструкция в README или в UI.

---

## 8. Технический стек и структура

- **React 19** — актуальные хуки и при необходимости новые API (например, для profiling).
- **Сборка:** Vite (или текущий бандлер проекта) с возможностью выбора режима (development / production / profiling).
- **Структура:** Отдельные страницы или разделы для каждого блока плана (Профилирование, useTransition, INP, Память), чтобы во время доклада можно было переключаться между сценариями без лишней настройки.
- **Документация:** README с шагами:
    - как запустить в dev/prod/profiling;
    - как воспроизвести каждый демо-сценарий;
    - ссылки на React DevTools, WDYR, Self-profiling API, Chrome Memory/Performance.

---

## 9. Чек-лист соответствия плану

| Пункт плана                                           | Требование (раздел) |
| ----------------------------------------------------- | ------------------- |
| development / production / profiling сборки           | 1.1                 |
| React DevTools — причины рендера, успешная мемоизация | 2.1                 |
| React Profiler — локально                             | 3.1                 |
| React Profiler — в продакшене                         | 3.2                 |
| DevTools Performance — локально                       | 4.1                 |
| Strict Mode и dev-сборка                              | 1.2, 4.2            |
| Self-profiling API                                    | 3.3                 |
| Профиль с useTransition                               | 5.1                 |
| Медленный рендер vs частые попытки                    | 5.2                 |
| UI starvation (useLayoutEffect, onInput, layout)      | 5.3                 |
| INP — React быстрый, INP 500 ms (GC, Layout)          | 6.1                 |
| useMemo/useCallback и INP (два кейса)                 | 6.2                 |
| Плохая мемоизация, нестабильные пропсы — WDYR         | 6.3                 |
| Кандидаты на мемоизацию — useWhyDidYouUpdate          | 6.4                 |
| Частые и длительные ререндеры                         | 6.5                 |
| queryObjects                                          | 7.1.1               |
| Performance monitor                                   | 7.1.2               |
| Memory — Detached elements                            | 7.1.3               |
| useMemo / reselect — не утечки                        | 7.1.4               |
| Memory — Allocations on timeline                      | 7.2.1               |
| Метод трёх снапшотов                                  | 7.2.2               |
